name: Smoke Test

on:
  push:
    branches: [main, develop]
    paths:
      - 'network-mapper/**'
      - '.github/workflows/smoke-test.yml'
  pull_request:
    branches: [main, develop]
    paths:
      - 'network-mapper/**'
      - '.github/workflows/smoke-test.yml'
  workflow_dispatch:

env:
  GO_VERSION: '1.21'

jobs:
  smoke-test:
    name: Smoke Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('network-mapper/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Build binary
      working-directory: network-mapper
      shell: bash
      run: |
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          go build -o network-mapper.exe .
        else
          go build -o network-mapper .
        fi

    - name: Run basic functionality tests
      working-directory: network-mapper
      shell: bash
      run: |
        # Make executable on Unix systems
        if [[ "${{ runner.os }}" != "Windows" ]]; then
          chmod +x network-mapper
          BINARY="./network-mapper"
        else
          BINARY="./network-mapper.exe"
        fi

        echo "Testing version output..."
        $BINARY --version

        echo "Testing help output..."
        $BINARY --help

        echo "Testing basic scan modes..."
        # Use gtimeout on macOS, timeout on Linux/Windows
        if [[ "${{ runner.os }}" == "macOS" ]]; then
          # Install coreutils for gtimeout
          brew install coreutils >/dev/null 2>&1 || true
          TIMEOUT_CMD="gtimeout"
        else
          TIMEOUT_CMD="timeout"
        fi

        $TIMEOUT_CMD 30s $BINARY --scan-mode quick --no-dns --no-services || true

        echo "Testing output format..."
        OUTPUT=$($TIMEOUT_CMD 30s $BINARY --scan-mode quick --no-dns --no-services 2>&1 || true)

        echo "=== DEBUG: Binary output ==="
        echo "$OUTPUT"
        echo "=== END DEBUG ==="

        # Verify key output patterns
        if [[ "$OUTPUT" != *"Network Mapper"* ]]; then
          echo "ERROR: Network Mapper header not found"
          exit 1
        fi

        if [[ "$OUTPUT" != *"Target ranges:"* ]]; then
          echo "ERROR: Target ranges output not found"
          exit 1
        fi

        if [[ "$OUTPUT" != *"Scan Complete"* ]]; then
          echo "ERROR: Scan completion message not found"
          exit 1
        fi

        echo "✅ Smoke test passed on ${{ runner.os }}"
      shell: bash

  validate-device-rules:
    name: Validate Device Rules
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('network-mapper/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Test device rules loading
      working-directory: network-mapper
      shell: bash
      run: |
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          go build -o network-mapper.exe .
          BINARY="./network-mapper.exe"
        else
          go build -o network-mapper .
          BINARY="./network-mapper"
        fi

        echo "Testing device rules export..."
        $BINARY --export-device-rules test-rules.yaml

        if [[ ! -f test-rules.yaml ]]; then
          echo "ERROR: Device rules export failed"
          exit 1
        fi

        echo "Testing device rules validation..."
        # Check YAML syntax with a simple Go program
        cat > yaml_check.go << 'EOF'
        package main

        import (
          "fmt"
          "os"
          "gopkg.in/yaml.v3"
        )

        func main() {
          data, err := os.ReadFile("test-rules.yaml")
          if err != nil {
            fmt.Printf("Error reading file: %v\n", err)
            os.Exit(1)
          }

          var v interface{}
          err = yaml.Unmarshal(data, &v)
          if err != nil {
            fmt.Printf("Error parsing YAML: %v\n", err)
            os.Exit(1)
          }

          fmt.Println("YAML syntax is valid")
        }
        EOF

        go run yaml_check.go

        echo "✅ Device rules validation passed"

  performance-benchmark:
    name: Performance Benchmark
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('network-mapper/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: Run performance benchmark
      working-directory: network-mapper
      shell: bash
      run: |
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          go build -o network-mapper.exe .
          BINARY="./network-mapper.exe"
        else
          go build -o network-mapper .
          BINARY="./network-mapper"
        fi

        echo "Running performance benchmark..."
        start_time=$(date +%s)

        # Run quick scan and measure time
        # Use gtimeout on macOS, timeout elsewhere
        if command -v gtimeout >/dev/null 2>&1; then
          TIMEOUT_CMD="gtimeout"
        elif command -v timeout >/dev/null 2>&1; then
          TIMEOUT_CMD="timeout"
        else
          echo "No timeout command available, skipping timeout"
          TIMEOUT_CMD=""
        fi

        if [[ -n "$TIMEOUT_CMD" ]]; then
          $TIMEOUT_CMD 60s $BINARY --scan-mode quick --no-dns --no-services > benchmark_output.txt
        else
          $BINARY --scan-mode quick --no-dns --no-services > benchmark_output.txt &
          SCAN_PID=$!
          sleep 60
          kill $SCAN_PID 2>/dev/null || true
          wait $SCAN_PID 2>/dev/null || true
        fi

        end_time=$(date +%s)
        duration=$((end_time - start_time))

        echo "Scan completed in ${duration} seconds"

        # Verify reasonable performance (should complete quickly)
        if [[ $duration -gt 45 ]]; then
          echo "WARNING: Scan took longer than expected (${duration}s > 45s)"
          echo "This may indicate performance regression"
        else
          echo "✅ Performance benchmark passed (${duration}s)"
        fi

        # Check for scan rate information
        if grep -q "IPs/second" benchmark_output.txt; then
          echo "✅ Performance metrics reported correctly"
        else
          echo "WARNING: Performance metrics not found in output"
        fi